package main

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
)

const goFileTemplate = `package {{.PackageName}}

// DO NOT EDIT: This file is automatically generated by the musale CLI tool.

const (
{{- range $key, $value := .Data }}
	{{$key}} = "{{ $value }}"
{{- end }}
)
`

// flattenMap recursively flattens a nested map into a flat map with underscore-separated keys.
func flattenMap(prefix string, m map[string]interface{}, flatMap map[string]string) {
	for k, v := range m {
		newKey := k
		if prefix != "" {
			newKey = prefix + "_" + k
		}
		switch v := v.(type) {
		case map[string]interface{}:
			flattenMap(newKey, v, flatMap)
		case string:
			flatMap[newKey] = strings.Join([]string{prefix, k}, ".")
		}
	}
}

func main() {
	var jsonFile string
	var outputFile string
	var packageName string

	var rootCmd = &cobra.Command{
		Use:   "musale",
		Short: "A CLI tool for generating localization keys as Go constants",
		Run: func(cmd *cobra.Command, args []string) {
			// Ensure the output file has the correct suffix
			if !strings.HasSuffix(outputFile, ".g.go") {
				outputFile = strings.TrimSuffix(outputFile, filepath.Ext(outputFile)) + ".g.go"
			}

			// Read JSON file
			file, err := os.Open(jsonFile)
			if err != nil {
				fmt.Printf("Error opening JSON file: %v\n", err)
				return
			}
			defer file.Close()

			fileContent, err := io.ReadAll(file)
			if err != nil {
				fmt.Printf("Error reading JSON file: %v\n", err)
				return
			}

			// Unmarshal JSON data into a map
			var data map[string]interface{}
			if err := json.Unmarshal(fileContent, &data); err != nil {
				fmt.Printf("Error unmarshalling JSON: %v\n", err)
				return
			}

			// Flatten the JSON structure
			flatData := make(map[string]string)
			flattenMap("", data, flatData)

			// Ensure the output directory exists
			outputDir := filepath.Dir(outputFile)
			if outputDir != "." && outputDir != "" {
				if err := os.MkdirAll(outputDir, 0755); err != nil {
					fmt.Printf("Error creating output directory: %v\n", err)
					return
				}
			}

			// Determine the package name
			if packageName == "" {
				baseName := filepath.Base(outputFile)
				packageName = strings.TrimSuffix(baseName, ".g.go")
			}

			// Create the Go file
			goFile, err := os.Create(outputFile)
			if err != nil {
				fmt.Printf("Error creating Go file: %v\n", err)
				return
			}
			defer goFile.Close()

			// Create the Go file content from the template
			tmpl, err := template.New("goFile").Parse(goFileTemplate)
			if err != nil {
				fmt.Printf("Error creating template: %v\n", err)
				return
			}

			dataForTemplate := struct {
				PackageName string
				Data        map[string]string
			}{
				PackageName: packageName,
				Data:        flatData,
			}

			if err := tmpl.Execute(goFile, dataForTemplate); err != nil {
				fmt.Printf("Error executing template: %v\n", err)
				return
			}

			fmt.Println("Go file generated successfully!")
		},
	}

	rootCmd.Flags().StringVarP(&jsonFile, "json", "j", "en.json", "The JSON file to read from")
	rootCmd.Flags().StringVarP(&outputFile, "output", "o", "localizations.go", "The Go file to write to")
	rootCmd.Flags().StringVarP(&packageName, "package", "p", "", "The package name to use in the generated Go file")

	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
